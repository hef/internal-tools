{"version":3,"file":"236.index.js","sources":["webpack:///./utils/github.ts","webpack:///./commands/binary/utils.ts","webpack:///./commands/binary/index.ts","webpack:///./util.ts","webpack:///./utils/config.ts","webpack:///./utils/docker/buildx.ts","webpack:///./utils/docker/common.ts","webpack:///./utils/types.ts"],"sourcesContent":["// istanbul ignore file\nimport { context, getOctokit } from '@actions/github';\nimport is from '@sindresorhus/is';\nimport { getArch, getDistro, readBuffer } from '../util';\nexport { getOctokit };\nexport function getBinaryName(cfg, version) {\n    const arch = getArch();\n    if (is.nonEmptyString(arch)) {\n        return `${cfg.image}-${version}-${getDistro()}-${arch}.tar.xz`;\n    }\n    return `${cfg.image}-${version}-${getDistro()}.tar.xz`;\n}\nfunction getBody(cfg, version) {\n    return `### Bug Fixes\n\n* **deps:** update dependency ${cfg.image} to v${version}`;\n}\nasync function findRelease(api, version) {\n    var _a;\n    try {\n        const res = await api.repos.getReleaseByTag({\n            ...context.repo,\n            tag: version,\n        });\n        return (_a = res.data) !== null && _a !== void 0 ? _a : null;\n    }\n    catch (e) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (e.status !== 404) {\n            throw e;\n        }\n    }\n    return null;\n}\nasync function createRelease(api, cfg, version) {\n    const { data } = await api.repos.createRelease({\n        ...context.repo,\n        tag_name: version,\n        name: version,\n        body: getBody(cfg, version),\n    });\n    return data;\n}\nexport async function updateRelease(api, cfg, version) {\n    const body = getBody(cfg, version);\n    const rel = await findRelease(api, version);\n    if (rel == null || (rel.name === version && rel.body === body)) {\n        return;\n    }\n    await api.repos.updateRelease({\n        ...context.repo,\n        release_id: rel.id,\n        name: version,\n        body,\n    });\n}\nexport async function uploadAsset(api, cfg, version) {\n    var _a;\n    try {\n        const rel = await findRelease(api, version);\n        let release_id = (_a = rel === null || rel === void 0 ? void 0 : rel.id) !== null && _a !== void 0 ? _a : 0;\n        if (rel == null) {\n            const { id } = await createRelease(api, cfg, version);\n            release_id = id;\n        }\n        const name = getBinaryName(cfg, version);\n        // fake because api issues\n        const data = (await readBuffer(`.cache/${name}`));\n        await api.repos.uploadReleaseAsset({\n            ...context.repo,\n            release_id,\n            data,\n            name,\n            headers: {\n                'content-type': 'application/octet-stream',\n                'content-length': data.length,\n            },\n        });\n    }\n    catch (e) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (e.status !== 404) {\n            throw e;\n        }\n    }\n}\nexport async function hasAsset(api, cfg, version) {\n    var _a;\n    const rel = await findRelease(api, version);\n    const name = getBinaryName(cfg, version);\n    return (_a = rel === null || rel === void 0 ? void 0 : rel.assets.some((a) => a.name === name)) !== null && _a !== void 0 ? _a : false;\n}\n","import { getInput } from '@actions/core';\nimport is from '@sindresorhus/is';\nimport { getArch, getArg, getDistro, isDryRun, readJson } from '../../util';\nimport { readDockerConfig } from '../../utils/config';\nimport { DockerPlatform, dockerBuildx, dockerRun, } from '../../utils/docker/common';\nimport log from '../../utils/logger';\nexport async function getConfig() {\n    var _a;\n    const configFile = getInput('config') || 'builder.json';\n    const cfg = await readJson(configFile);\n    if (!is.object(cfg)) {\n        throw new Error('missing-config');\n    }\n    if (!is.string(cfg.image)) {\n        cfg.image = getInput('image', { required: true });\n    }\n    if (!is.string(cfg.buildArg)) {\n        cfg.buildArg = cfg.image.toUpperCase() + '_VERSION';\n    }\n    await readDockerConfig(cfg);\n    return {\n        ...cfg,\n        ignoredVersions: (_a = cfg.ignoredVersions) !== null && _a !== void 0 ? _a : [],\n        dryRun: isDryRun(),\n        lastOnly: getArg('last-only') == 'true',\n        buildArgs: getArg('build-args', { multi: true }),\n    };\n}\nexport async function createBuilderImage(ws, { buildArgs }) {\n    log('Creating builder image');\n    const args = [\n        'build',\n        '--load',\n        '-t',\n        'builder',\n        '--build-arg',\n        `DISTRO=${getDistro()}`,\n    ];\n    const arch = getArch();\n    if (is.nonEmptyString(arch)) {\n        args.push('--platform', DockerPlatform[arch]);\n    }\n    if (is.nonEmptyArray(buildArgs)) {\n        args.push(...buildArgs.map((b) => `--build-arg=${b}`));\n    }\n    await dockerBuildx(...args, ws);\n}\nexport async function runBuilder(ws, version) {\n    const args = ['--name', 'builder', '--volume', `${ws}/.cache:/cache`];\n    const arch = getArch();\n    if (is.nonEmptyString(arch)) {\n        args.push('--platform', DockerPlatform[arch]);\n    }\n    await dockerRun(...args, 'builder', version);\n}\n","import 'source-map-support/register';\nimport { setFailed } from '@actions/core';\nimport chalk from 'chalk';\nimport { getPkgReleases } from 'renovate/dist/datasource';\nimport { get as getVersioning } from 'renovate/dist/versioning';\nimport shell from 'shelljs';\nimport { getArg, getWorkspace } from '../../util';\nimport { init } from '../../utils/docker/buildx';\nimport { getOctokit, hasAsset, updateRelease, uploadAsset, } from '../../utils/github';\nimport log from '../../utils/logger';\nimport { createBuilderImage, getConfig, runBuilder } from './utils';\nlet builds = 99;\nlet latestStable;\nfunction getVersions(versions) {\n    return {\n        releases: versions.map((version) => ({\n            version,\n        })),\n    };\n}\nasync function getBuildList({ datasource, depName, versioning, startVersion, ignoredVersions, lastOnly, forceUnstable, versions, latestVersion, }) {\n    var _a;\n    log('Looking up versions');\n    const ver = getVersioning(versioning);\n    const pkgResult = versions\n        ? getVersions(versions)\n        : await getPkgReleases({\n            datasource,\n            depName,\n            versioning,\n        });\n    if (!pkgResult) {\n        return [];\n    }\n    let allVersions = pkgResult.releases\n        .map((v) => v.version)\n        .filter((v) => ver.isVersion(v) && ver.isCompatible(v, startVersion));\n    log(`Found ${allVersions.length} total versions`);\n    if (!allVersions.length) {\n        return [];\n    }\n    allVersions = allVersions\n        .filter((v) => /* istanbul ignore next */ { var _a; /* istanbul ignore next */ return !((_a = ver.isLessThanRange) === null || _a === void 0 ? void 0 : _a.call(ver, v, startVersion)); })\n        .filter((v) => !ignoredVersions.includes(v));\n    if (!forceUnstable) {\n        log('Filter unstable versions');\n        allVersions = allVersions.filter((v) => ver.isStable(v));\n    }\n    log(`Found ${allVersions.length} versions within our range`);\n    log(`Candidates:`, allVersions.join(', '));\n    latestStable =\n        latestVersion ||\n            (\n            /* istanbul ignore next: not testable ts */\n            (_a = pkgResult.tags) === null || _a === void 0 ? void 0 : _a.latest) ||\n            allVersions.filter((v) => ver.isStable(v)).pop();\n    log('Latest stable version is ', latestStable);\n    if (latestStable && !allVersions.includes(latestStable)) {\n        log.warn(`LatestStable '${latestStable}' not buildable, candidates: `, allVersions.join(', '));\n    }\n    const lastVersion = allVersions[allVersions.length - 1];\n    log('Most recent version is ', lastVersion);\n    if (lastOnly) {\n        log('Building last version only');\n        allVersions = [latestStable && !forceUnstable ? latestStable : lastVersion];\n    }\n    // istanbul ignore else\n    if (allVersions.length) {\n        log('Build list: ', allVersions.join(', '));\n    }\n    else {\n        log('Nothing to build');\n    }\n    return allVersions;\n}\nexport async function run() {\n    try {\n        log.info('Builder started');\n        const ws = getWorkspace();\n        const cfg = await getConfig();\n        if (cfg.dryRun) {\n            log.warn(chalk.yellow('[DRY_RUN] detected'));\n            cfg.lastOnly = true;\n        }\n        const token = getArg('token', { required: true });\n        const api = getOctokit(token);\n        log('config:', JSON.stringify(cfg));\n        const versions = await getBuildList(cfg);\n        if (versions.length === 0) {\n            setFailed(`No versions found.`);\n            return;\n        }\n        shell.mkdir('-p', `${ws}/.cache`);\n        await init();\n        await createBuilderImage(ws, cfg);\n        const failed = [];\n        for (const version of versions) {\n            await updateRelease(api, cfg, version);\n            if (await hasAsset(api, cfg, version)) {\n                if (cfg.dryRun) {\n                    log.warn(chalk.yellow('[DRY_RUN] Would skipp existing version:'), version);\n                }\n                else {\n                    log('Skipping existing version:', version);\n                    continue;\n                }\n            }\n            // istanbul ignore if\n            if (builds-- <= 0) {\n                log.info('Build limit reached');\n                break;\n            }\n            log.info('Processing version:', version);\n            try {\n                log('Runing builder:', version);\n                await runBuilder(ws, version);\n                if (cfg.dryRun) {\n                    log.warn(chalk.yellow('[DRY_RUN] Would upload release asset:'), version);\n                }\n                else {\n                    log('Uploading release:', version);\n                    await uploadAsset(api, cfg, version);\n                }\n            }\n            catch (e) {\n                failed.push(version);\n                // eslint-disable-next-line\n                log(`Version ${version} failed: ${e.message}`, e.stack);\n            }\n        }\n        if (failed.length) {\n            setFailed(`Versions failed: ${failed.join(', ')}`);\n        }\n    }\n    catch (error) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        log(error.stack);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        setFailed(error.message);\n    }\n}\n","import { promises as fs } from 'fs';\nimport { join } from 'path';\nimport { endGroup, getInput, startGroup } from '@actions/core';\nimport { exec as _exec } from '@actions/exec';\nimport findUp from 'find-up';\nimport { ExecError } from './utils/types';\nconst DEFAULT_DISTRO = 'focal';\n/** webpack workaround for dynamic require */\nconst _require = eval('require');\nfunction _import(path) {\n    return Promise.resolve(_require(path));\n}\nexport async function exec(cmd, args, options) {\n    let stdout = '';\n    let stderr = '';\n    let code;\n    try {\n        startGroup(`${cmd} ${args.join(' ')}`);\n        code = await _exec(cmd, args, {\n            ...options,\n            ignoreReturnCode: true,\n            listeners: {\n                stdout: (data) => {\n                    stdout += data.toString();\n                },\n                stderr: (data) => {\n                    stderr += data.toString();\n                },\n            },\n        });\n    }\n    finally {\n        endGroup();\n    }\n    if (code) {\n        throw new ExecError(code, stdout, stderr, `${cmd} ${args.join(' ')}`);\n    }\n    return { code, stdout, stderr };\n}\n/**\n * Get environment variable or empty string.\n * Used for easy mocking.\n * @param key variable name\n */\nexport function getEnv(key) {\n    var _a;\n    return (_a = process.env[key]) !== null && _a !== void 0 ? _a : '';\n}\nexport function isCI() {\n    return !!getEnv('CI');\n}\nexport function isDryRun() {\n    const val = getInput('dry-run') || getEnv('DRY_RUN');\n    return (!!val && val === 'true') || !isCI();\n}\nexport function getWorkspace() {\n    return getEnv('GITHUB_WORKSPACE') || process.cwd();\n}\nexport function getDistro() {\n    return getEnv('DISTRO') || getEnv('FLAVOR') || DEFAULT_DISTRO;\n}\nexport function getArch() {\n    return getEnv('ARCH');\n}\nexport async function readJson(file) {\n    const path = join(getWorkspace(), file);\n    const res = await _import(path);\n    // istanbul ignore next\n    return 'default' in res ? res === null || res === void 0 ? void 0 : res.default : res;\n}\nexport async function readFile(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path, 'utf8');\n}\nexport async function readBuffer(file) {\n    const path = join(getWorkspace(), file);\n    return await fs.readFile(path);\n}\nexport const MultiArgsSplitRe = /\\s*(?:[;,]|$)\\s*/;\nexport function getArg(name, opts) {\n    const val = getInput(name, opts);\n    return (opts === null || opts === void 0 ? void 0 : opts.multi) ? val.split(MultiArgsSplitRe).filter(Boolean) : val;\n}\nlet _pkg;\n/**\n * Resolve path for a file relative to renovate root directory (our package.json)\n * @param file a file to resolve\n */\nexport async function resolveFile(file) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    if (!_pkg) {\n        _pkg = findUp('package.json', { cwd: __dirname, type: 'file' });\n    }\n    const pkg = await _pkg;\n    // istanbul ignore if\n    if (!pkg) {\n        throw new Error('Missing package.json');\n    }\n    return join(pkg, '../', file);\n}\n","import is from '@sindresorhus/is';\nimport { readFile } from '../util';\nconst keys = [\n    'datasource',\n    'depName',\n    'buildArg',\n    'versioning',\n    'latestVersion',\n];\nfunction checkArgs(cfg, groups) {\n    for (const key of keys) {\n        if (!is.string(cfg[key]) && is.nonEmptyString(groups[key])) {\n            cfg[key] = groups[key];\n        }\n    }\n}\nexport async function readDockerConfig(cfg) {\n    const dockerFileRe = new RegExp('# renovate: datasource=(?<datasource>.*?) depName=(?<depName>.*?)( versioning=(?<versioning>.*?))?\\\\s' +\n        `(?:ENV|ARG) ${cfg.buildArg}=(?<latestVersion>.*)\\\\s`, 'g');\n    const dockerfile = await readFile('Dockerfile');\n    const m = dockerFileRe.exec(dockerfile);\n    if (m && m.groups) {\n        checkArgs(cfg, m.groups);\n    }\n}\n","import log from '../logger';\nimport { docker, dockerBuildx, dockerRun } from './common';\nconst SupportedPlatforms = 'arm64';\nexport async function init() {\n    const buildx = await dockerBuildx('ls');\n    if (buildx.stdout.includes('renovatebot-builder')) {\n        log('Buildx already initialized');\n        return;\n    }\n    log.info('Configure buildx');\n    await docker('info');\n    // install emulations\n    // https://github.com/docker/setup-qemu-action/blob/9d419fda7df46b2bcd38fadda3ec44f4748d25e1/src/main.ts#L22\n    await dockerRun('--privileged', 'tonistiigi/binfmt', '--install', SupportedPlatforms);\n    await dockerBuildx('version');\n    await dockerBuildx('create', '--name', 'renovatebot-builder', '--driver', 'docker-container', '--use');\n    await dockerBuildx('inspect', '--bootstrap');\n}\n","import { exec } from '../../util';\nimport log from '../logger';\nexport var DockerPlatform;\n(function (DockerPlatform) {\n    DockerPlatform[\"x86_64\"] = \"linux/amd64\";\n    DockerPlatform[\"aarch64\"] = \"linux/arm64\";\n})(DockerPlatform || (DockerPlatform = {}));\nexport async function docker(...args) {\n    return await exec('docker', [...args]);\n}\nexport async function dockerRun(...args) {\n    await docker('run', '--rm', ...args);\n}\nexport async function dockerBuildx(...args) {\n    return await docker('buildx', ...args);\n}\nexport async function dockerTag({ image, imagePrefix, src, tgt, }) {\n    return await exec('docker', [\n        'tag',\n        `${imagePrefix}/${image}:${src}`,\n        `${imagePrefix}/${image}:${tgt}`,\n    ]);\n}\nexport async function dockerPrune() {\n    log('Pruning docker system');\n    await docker('system', 'prune', '--force', '--all');\n}\nexport async function dockerDf() {\n    log('Docker system disk usage');\n    await docker('system', 'df');\n}\n","export class ExecError extends Error {\n    constructor(code, stdout, stderr, cmd) {\n        super(`ExecError: (${code}) ` + stderr.split('\\n').slice(-10).join('\\n'));\n        this.code = code;\n        this.stdout = stdout;\n        this.stderr = stderr;\n        this.cmd = cmd;\n        this.name = 'ExecError';\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;A","sourceRoot":""}